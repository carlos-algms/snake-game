{"version":3,"sources":["webpack://snake-game/./src/Direction.ts","webpack://snake-game/./src/Item.ts","webpack://snake-game/./src/Player.ts","webpack://snake-game/./src/Stage/StageCanvas.ts","webpack://snake-game/./src/Game.ts","webpack://snake-game/./src/ScoreUi.ts","webpack://snake-game/./src/Score.ts","webpack://snake-game/./src/main.ts","webpack://snake-game/./src/index.ts"],"names":["Direction","OffsetDirection","Item","position","x","y","moveRandom","gridSize","this","Math","floor","random","Player","facingDirection","justMovedDirection","offset","Still","tailSize","INITIAL_TAIL_SIZE","trail","changeFacingDirection","direction","isDirectionChangePossible","Up","Right","Down","Left","move","moveOffset","maintainTrail","push","length","shift","StageCanvas","canvasSize","rectangleSize","calculateSizes","parent","canvasElement","parentElement","clientHeight","clientWidth","smallerSize","width","height","clear","ctx","fillStyle","fillRect","drawRectangle","drawStep","drawItem","document","getElementById","timeoutId","window","addEventListener","clearTimeout","setTimeout","getContext","Game","score","isMoving","stage","player","item","resetCurrentScore","evt","code","eventCodeToDirection","key","checkForHits","draw","movePlayer","forEach","step","checkHit","updateBestScore","incrementCurrentScore","posA","posB","ScoreUi","scoreEl","bestScoreEl","textContent","toString","BEST_SCORE_KEY","Score","currentScore","bestScore","scoreUi","restoreBestScore","onBestScoreUpdate","onScoreUpdate","localStorage","setItem","storedBestScore","parseInt","getItem","error","console","game","setInterval","tick","keyPressed","main"],"mappings":"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","file":"index-ff0310b2eb79bec1eba1.js","sourcesContent":["/* eslint-disable no-shadow */\nexport enum Direction {\n  Up,\n  Right,\n  Down,\n  Left,\n}\n\nexport enum OffsetDirection {\n  Up = -1,\n  Right = 1,\n  Down = 1,\n  Left = -1,\n  Still = 0,\n}\n\nexport function eventCodeToDirection(code: string): Direction | null {\n  switch (code) {\n    case 'ArrowLeft':\n      return Direction.Left;\n    case 'ArrowUp':\n      return Direction.Up;\n    case 'ArrowRight':\n      return Direction.Right;\n    case 'ArrowDown':\n      return Direction.Down;\n    default:\n      return null;\n  }\n}\n","export class Item {\n  position: XYPosition = {\n    x: 0,\n    y: 0,\n  };\n\n  moveRandom = (gridSize: number): void => {\n    this.position.x = Math.floor(Math.random() * gridSize);\n    this.position.y = Math.floor(Math.random() * gridSize);\n  };\n}\n","import { Direction, OffsetDirection } from './Direction';\n\nexport class Player {\n  static readonly INITIAL_TAIL_SIZE = 5;\n\n  readonly position: XYPosition = {\n    x: 10,\n    y: 10,\n  };\n\n  private facingDirection: Direction | null = null;\n\n  private justMovedDirection = false;\n\n  /**\n   * Holds in which direction the player is facing\n   */\n  readonly offset: { x: OffsetDirection; y: OffsetDirection } = {\n    x: OffsetDirection.Still,\n    y: OffsetDirection.Still,\n  };\n\n  tailSize = Player.INITIAL_TAIL_SIZE;\n\n  trail: XYPosition[] = [];\n\n  changeFacingDirection = (direction: Direction | null, gridSize: number): boolean => {\n    if (direction === null || direction === this.facingDirection) {\n      return false;\n    }\n\n    if (!this.isDirectionChangePossible(direction)) {\n      return false;\n    }\n\n    // TODO check if it is possible to change to the desired direction\n    switch (direction) {\n      case Direction.Up:\n        this.offset.x = OffsetDirection.Still;\n        this.offset.y = OffsetDirection.Up;\n        break;\n      case Direction.Right:\n        this.offset.x = OffsetDirection.Right;\n        this.offset.y = OffsetDirection.Still;\n        break;\n      case Direction.Down:\n        this.offset.x = OffsetDirection.Still;\n        this.offset.y = OffsetDirection.Down;\n        break;\n      case Direction.Left:\n        this.offset.x = OffsetDirection.Left;\n        this.offset.y = OffsetDirection.Still;\n        break;\n      default:\n        break;\n    }\n\n    this.facingDirection = direction;\n    this.justMovedDirection = true;\n    this.move(gridSize);\n\n    return true;\n  };\n\n  private isDirectionChangePossible = (direction: Direction) => {\n    const { facingDirection } = this;\n\n    if (facingDirection === null) {\n      return true;\n    }\n\n    if (direction === Direction.Up || direction === Direction.Down) {\n      return facingDirection === Direction.Left || facingDirection === Direction.Right;\n    }\n\n    return facingDirection === Direction.Up || facingDirection === Direction.Down;\n  };\n\n  moveOffset = (gridSize: number): XYPosition => {\n    if (this.justMovedDirection) {\n      this.justMovedDirection = false;\n      return this.position;\n    }\n\n    return this.move(gridSize);\n  };\n\n  private move(gridSize: number) {\n    const { position, offset } = this;\n\n    this.maintainTrail();\n\n    if (offset.x || offset.y) {\n      position.x += offset.x;\n      position.y += offset.y;\n\n      if (position.x < 0) {\n        position.x = gridSize - 1;\n      }\n\n      if (position.x > gridSize - 1) {\n        position.x = 0;\n      }\n\n      if (position.y < 0) {\n        position.y = gridSize - 1;\n      }\n\n      if (position.y > gridSize - 1) {\n        position.y = 0;\n      }\n    }\n\n    // TODO maybe a good place for check for hits\n\n    return position;\n  }\n\n  private maintainTrail(): void {\n    const { trail, tailSize, position } = this;\n\n    trail.push({ ...position });\n\n    while (trail.length > tailSize) {\n      trail.shift();\n    }\n  }\n}\n","export class StageCanvas {\n  readonly gridSize = 20;\n\n  readonly canvasElement: HTMLCanvasElement;\n\n  canvasSize = 0;\n\n  rectangleSize = 0;\n\n  private get ctx() {\n    return this.canvasElement.getContext('2d') as CanvasRenderingContext2D;\n  }\n\n  constructor() {\n    this.canvasElement = document.getElementById('app-canvas') as HTMLCanvasElement;\n    this.calculateSizes();\n    let timeoutId = 0;\n    this.clear();\n\n    window.addEventListener('resize', () => {\n      clearTimeout(timeoutId);\n      timeoutId = window.setTimeout(this.calculateSizes, 150);\n    });\n  }\n\n  private calculateSizes = () => {\n    const parent = this.canvasElement.parentElement as HTMLDivElement;\n    const { clientHeight, clientWidth } = parent;\n    let smallerSize = clientHeight < clientWidth ? clientHeight : clientWidth;\n\n    if (smallerSize < 300) {\n      smallerSize = 300;\n    }\n\n    this.rectangleSize = Math.floor(smallerSize / this.gridSize);\n\n    this.canvasSize = this.rectangleSize * this.gridSize;\n    this.canvasElement.width = this.canvasSize;\n    this.canvasElement.height = this.canvasSize;\n  };\n\n  clear = (): void => {\n    const { ctx, canvasSize } = this;\n    ctx.fillStyle = 'black';\n    ctx.fillRect(0, 0, canvasSize, canvasSize);\n  };\n\n  private drawRectangle = (x: number, y: number) => {\n    const { ctx, rectangleSize } = this;\n    ctx.fillRect(x * rectangleSize, y * rectangleSize, rectangleSize - 2, rectangleSize - 2);\n  };\n\n  drawStep = ({ x, y }: XYPosition): void => {\n    this.ctx.fillStyle = 'lime';\n    this.drawRectangle(x, y);\n  };\n\n  drawItem = ({ x, y }: XYPosition): void => {\n    this.ctx.fillStyle = 'red';\n    this.drawRectangle(x, y);\n  };\n}\n","import { eventCodeToDirection } from './Direction';\nimport { Item } from './Item';\nimport { Player } from './Player';\nimport Score from './Score';\nimport { StageCanvas } from './Stage/StageCanvas';\n\nexport class Game {\n  player: Player;\n\n  stage: StageCanvas;\n\n  item: Item;\n\n  isMoving = false;\n\n  constructor(private readonly score: Score) {\n    this.stage = new StageCanvas();\n    this.player = new Player();\n    this.item = new Item();\n\n    this.item.moveRandom(this.stage.gridSize);\n    this.stage.drawItem(this.item.position);\n    this.stage.drawStep(this.player.position);\n\n    score.resetCurrentScore();\n  }\n\n  keyPressed(evt: KeyboardEvent): void {\n    const direction = eventCodeToDirection(evt.key ?? evt.code);\n\n    if (this.player.changeFacingDirection(direction, this.stage.gridSize)) {\n      this.isMoving = true;\n      this.checkForHits();\n      this.draw();\n    }\n  }\n\n  tick(): void {\n    if (this.isMoving) {\n      this.movePlayer();\n      this.checkForHits();\n      this.draw();\n    }\n  }\n\n  private movePlayer() {\n    const { stage, player } = this;\n    player.moveOffset(stage.gridSize);\n  }\n\n  private checkForHits() {\n    const { stage, player, item, score } = this;\n\n    player.trail.forEach((step) => {\n      if (this.checkHit(step, player.position)) {\n        // TODO game over ?\n        player.tailSize = Player.INITIAL_TAIL_SIZE;\n        score.updateBestScore();\n        score.resetCurrentScore();\n      }\n    });\n\n    if (this.checkHit(player.position, item.position)) {\n      player.tailSize++;\n      item.moveRandom(stage.gridSize);\n      score.incrementCurrentScore();\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  private checkHit(posA: XYPosition, posB: XYPosition): boolean {\n    return posA.x === posB.x && posA.y === posB.y;\n  }\n\n  private draw() {\n    const { stage, player, item } = this;\n    stage.clear();\n    player.trail.forEach((step) => stage.drawStep(step));\n    stage.drawItem(item.position);\n  }\n}\n","export default class ScoreUi {\n  scoreEl: HTMLDivElement;\n\n  bestScoreEl: HTMLDivElement;\n\n  constructor() {\n    this.scoreEl = document.getElementById('score') as HTMLDivElement;\n    this.bestScoreEl = document.getElementById('bestScore') as HTMLDivElement;\n  }\n\n  onScoreUpdate(score: number): void {\n    this.scoreEl.textContent = score.toString();\n  }\n\n  onBestScoreUpdate(score: number): void {\n    this.bestScoreEl.textContent = score.toString();\n  }\n}\n","/* eslint-disable class-methods-use-this */\nimport ScoreUi from './ScoreUi';\n\nconst BEST_SCORE_KEY = 'BEST_SCORE';\n\nexport default class Score {\n  private currentScore = 0;\n\n  private bestScore = 0;\n\n  private readonly scoreUi: ScoreUi;\n\n  constructor() {\n    this.scoreUi = new ScoreUi();\n    this.restoreBestScore();\n    this.scoreUi.onBestScoreUpdate(this.bestScore);\n  }\n\n  getCurrentScore(): number {\n    return this.currentScore;\n  }\n\n  getBestScore(): number {\n    return this.bestScore;\n  }\n\n  incrementCurrentScore(): void {\n    this.currentScore += 1;\n    this.scoreUi.onScoreUpdate(this.currentScore);\n  }\n\n  resetCurrentScore(): void {\n    this.currentScore = 0;\n    this.scoreUi.onScoreUpdate(this.currentScore);\n  }\n\n  updateBestScore(): void {\n    if (this.currentScore > this.bestScore) {\n      this.bestScore = this.currentScore;\n      this.scoreUi.onBestScoreUpdate(this.bestScore);\n      localStorage.setItem(BEST_SCORE_KEY, this.bestScore.toString());\n    }\n  }\n\n  private restoreBestScore() {\n    try {\n      const storedBestScore = parseInt(localStorage.getItem(BEST_SCORE_KEY) ?? '0', 10);\n      this.bestScore = storedBestScore;\n    } catch (error) {\n      // eslint-disable-next-line no-console\n      console.error(error);\n    }\n  }\n}\n","import { Game } from './Game';\nimport Score from './Score';\n\nconst intervalMs = 1000 / 10;\n\nexport default function main(): void {\n  const score = new Score();\n  const game = new Game(score);\n\n  // TODO should be possible to increase the game speed by changing the interval value\n  setInterval(mainLoop, intervalMs);\n  document.addEventListener('keydown', handleGlobalKeyPress);\n\n  function mainLoop() {\n    game.tick();\n  }\n\n  function handleGlobalKeyPress(evt: KeyboardEvent) {\n    game.keyPressed(evt);\n  }\n}\n","import main from './main';\n\nimport './styles/reset.css';\nimport './styles/ui.css';\n\nmain();\n\nexport default null;\n"],"sourceRoot":""}